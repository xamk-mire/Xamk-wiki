# Olio-ohjelmointi

## What is class/object
##### ---------------------------------------------------------------------------------------------------------------

##### Muuta hyvää materiaalia:[C# Class and Object (With Examples) (programiz.com)](https://www.programiz.com/csharp-programming/class-objects)
-----------------------------------------------------------------------------------------

 A class in C# is a blueprint for creating objects. It defines a type by bundling data and methods (functions) that operate on the data into a single unit. The data and methods contained in a class are called members of the class.
- **Data Members:**These are usually fields or properties that store data.
- **Methods:**These are functions that define actions the class can perform.

### WHY DO WE USE CLASSES?
1. **Encapsulation:**Classes encapsulate data and methods into a single unit. This means that a class can hide its internal workings from the outside world and expose only what is necessary. This makes the code more secure and less prone to errors.
1. **Reusability:**Once a class is written, it can be reused in different parts of a program without the need to rewrite code.
1. **Modularity:**Classes allow for dividing a complex problem into smaller, more manageable parts. Each class can be developed independently of others.
1. **Inheritance:**Classes support the concept of inheritance, which means a new class can be derived from an existing class, inheriting its properties and methods. This promotes code reuse and can simplify code maintenance.
1. **Polymorphism:**Classes allow for polymorphism, where a single interface can be used to represent different underlying data types.

### BENEFITS OF USING CLASSES IN C#
1. **Organization:**Classes help in organizing and structuring the code, making it easier to read and maintain.
1. **Data Safety:**By using access modifiers like`public`,`private`,`protected`, etc., classes can control who can access their data, enhancing security and data integrity.
1. **Abstraction:**Classes allow for abstracting complex problems into simpler, understandable components.
1. **Testability:**Classes make it easier to write unit tests for specific functionalities, leading to more robust and error-free code.

![]($@PLUGINFILEBYCONTEXT*2765010@$/mod_book/chapter/56844/image.png)

## What does OOP mean
#### Johdanto

 Olio-ohjelmointi (OOP, eli object oriented progrraming) on ohjelmoinnin paradigma, joka keskittyy objektien ja luokkien käyttöön ohjelmistosuunnittelussa. OOP perustuu useisiin keskeisiin konsepteihin, joista`[inheritance](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/inheritance)`(perintä) ja`interfaces`(rajapinnat) ovat kaksi merkittävintä. Mutta ennen kuin syvennymme niihin, ymmärretään ensin perustiedot OOP:sta.

 OOP:n tavoitteena on parantaa ohjelmiston modulaarisuutta, jälleenkäytettävyyttä ja ylläpidettävyyttä kapseloinnin, perinnän, polymorfismin ja yhdistämisen avulla.
- **[Kapselointi](https://www.geeksforgeeks.org/c-sharp-encapsulation/)**: Kapselointi tarkoittaa datan (muuttujat) ja siihen liittyvän toiminnallisuuden (metodit) yhdistämistä yhdeksi yksiköksi (objektiksi tai luokaksi). Kapseloinnin avulla voimme piilottaa yksityiskohdat ja näyttää vain olennaiset ominaisuudet.

![](@@PLUGINFILE@@/image%20%281%29.png)
- **[Perintä ](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/inheritance) (Inheritance)**: Se mahdollistaa olemassa olevan luokan ominaisuuksien ja toimintojen perimisen, jolloin voidaan luoda uusi luokka ilman tarvetta kirjoittaa samoja toimintoja uudestaan. Se edistää koodin uudelleenkäytettävyyttä ja hierarkkista luokkarakennetta.

![](@@PLUGINFILE@@/image%20%282%29.png)
- **[Polymorfismi](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/polymorphism) ([wikipedia](https://fi.wikipedia.org/wiki/Polymorfismi) ) (**polymorphism):**Polymorfismi**on[olio-ohjelmoinnissa](https://fi.wikipedia.org/wiki/Olio-ohjelmointi) esiintyvä käsite, jonka mukaan[aliluokat](https://fi.wikipedia.org/wiki/Luokka_(ohjelmointi)) voivat määrittää oman yksilöllisen toimintansa ja silti jakaa saman toiminnallisuuden yläluokan kanssa . Se voidaan toteuttaa monin eri tavoin, kuten metodin ylikuormituksen ja ylikirjoituksen avulla. Esimerkissä Summa-methodi on toteutettu kaksi kertaa, mutta ne palauttavat ja ottavat sisään eri tyyppisen muuttujan.

![](@@PLUGINFILE@@/image%20%283%29.png)
- **[Yhdistäminen ](https://www.c-sharpcorner.com/UploadFile/ff2f08/inheritance-vs-composition/) (Composition)**: Se tarkoittaa, että yksi luokka sisältää toisen luokan ilmentymiä. Se on tapa yhdistää useita yksinkertaisia osia yhteen monimutkaisempaan kokonaisuuteen.

![](@@PLUGINFILE@@/image%20%284%29.png)

 Palataksemme**perintään**ja**rajapintoihin**:
- **Perintä**: Kuten aiemmin mainittiin, perinnällä uusi luokka voi hyödyntää ja laajentaa olemassa olevan luokan toimintoja. Tämä mahdollistaa koodin jälleenkäytettävyyden ja vähentää toistoa. Perintä kuvaa usein "on" -suhdetta, esimerkiksi "Koira on eläin".
- **Rajapinnat**: Ne antavat mahdollisuuden määritellä "sopimus", jonka toteuttavat luokat on täytettävä. Toisin kuin perintä, joka kuvaa "on" -suhdetta, rajapinnat usein kuvaavat "voi tehdä" -suhteita, esimerkiksi "Lentokone voi lentää". Rajapinnat antavat luokille mahdollisuuden toteuttaa useita toimintoja ilman monen perinnän monimutkaisuutta. Rajapintojen avulla voidaan hyödyntää monia tekniikoita tai patterneja kuten[ Dependency Injection](https://www.c-sharpcorner.com/UploadFile/85ed7a/dependency-injection-in-C-Sharp/) .

 Nämä kaksi konseptia ovat olennaisia olio-ohjelmoinnin ymmärtämisessä, ja ne tarjoavat kehittäjille tehokkaita välineitä ohjelmiston suunnitteluun ja toteutukseen.

### Olio-ohjelmoinnin Tekniikat
# Olio-ohjelmoinnin Tekniikat ja Niiden Ratkaisemat Ongelmat

 Olio-ohjelmoinnin (OOP) ytimessä on ajatus jakaa sovellus loogisiin yksiköihin,**olioihin**, jotka kuvaavat todellisen maailman käsitteitä tai sovelluksen osia. Tällä sivulla esittelemme OOP-konsepteja (kapselointi, perintä, polymorfismi, yhdistäminen ja rajapinnat), kerromme mitä ongelmia ne ratkaisevat ja annamme C#-kieliset koodi-esimerkit.
---

## Kapselointi (Encapsulation)

**Kapseloinnin ongelma, joka ratkaistaan:**
Ilman kapselointia luokan sisäisiä tietoja (muuttujia) voidaan lukemattomilla tavoilla lukea ja muokata suoraan ulkopuolelta, mikä voi rikkoa luokan eheyttä ja vaikeuttaa ylläpitoa.

**Ratkaisu:**
*Kapselointi*kätkee luokan toteutuksen yksityiskohdat tarjoamalla julkiset`get`- ja`set`-metodit (tai ominaisuudet) muuttujien käsittelyyn. Näin varmistetaan tietoturva ja selkeä rajapinta ulkoisille käyttäjille.

### Ennen kapselointia (ongelma)

```
`
![](@@PLUGINFILE@@/image.png)
    `
```

### Kapseloinnin avulla (ratkaisu)

```
`
![](@@PLUGINFILE@@/image%20%281%29.png)

![](@@PLUGINFILE@@/image%20%282%29.png)
`
```
---

## Perintä (Inheritance)

**Perinnän ongelma, joka ratkaistaan:**
Koodin toistuminen, moninkertainen kopiointi ja hankalasti hallittavat rinnakkaiset luokkien versiot.

**Ratkaisu:**
*Perintä*sallii uuden luokan (aliluokan) periä olemassa olevan luokan (yläluokan) ominaisuudet ja metodit, jolloin koodin uudelleenkäyttö ja ylläpito helpottuvat. Perintä kuvaa usein*“on-suhdetta”*(esim. “Koira on Eläin”).

### Ilman perintää (ongelma)

```
`![](@@PLUGINFILE@@/image%20%283%29.png)`
```

### Perinnän avulla (ratkaisu)

```
`![](@@PLUGINFILE@@/image%20%284%29.png)`
```
---

## Polymorfismi (Polymorphism)

**Polymorfismin ongelma, joka ratkaistaan:**
Tarve käsitellä luokkien olioita*yhtenäisellä*tavalla ilman, että kutsujan täytyy tietää tarkka toteutus.

**Ratkaisu:**
*Polymorfismi*mahdollistaa sen, että sama metodikutsu voi toimia eri tavoin riippuen siitä, minkä luokan olio (ylä- vai aliluokka) on kyseessä. C#-kielessä polymorfismin toteuttaa esimerkiksi`virtual`,`override`,`abstract`sekä interfacet.

### Metodin kutsut ilman polymorfismia (ongelma)

```
`![](@@PLUGINFILE@@/image%20%285%29.png)

// Mutta jos meillä on 10 eläintyyppiä, koodi monimutkaistuu...
 `
```

### Polymorfismin avulla (ratkaisu)

```
`![](@@PLUGINFILE@@/image%20%286%29.png)

![](@@PLUGINFILE@@/image%20%287%29.png)`
```
---

## Yhdistäminen (Composition)

**Yhdistämisen ongelma, joka ratkaistaan:**
Liian suuri “kaikki yhdessä” -luokka, joka sisältää liikaa vastuita ja tekee koodista vaikeasti ylläpidettävää.

**Ratkaisu:**
*Yhdistäminen (Composition)*tarkoittaa, että luokka koostuu muiden luokkien ilmentymistä. Tämä mahdollistaa loogisesti pienempien moduulien käytön, mikä parantaa selkeyttä ja ylläpidettävyyttä.

### Ilman yhdistämistä (ongelma)

```
`![](@@PLUGINFILE@@/image%20%288%29.png)`
```

### Yhdistämisen avulla (ratkaisu)

```
`![](@@PLUGINFILE@@/image%20%289%29.png)

![](@@PLUGINFILE@@/image%20%2810%29.png)
`
```
---

## Rajapinnat (Interfaces)

**Rajapintojen ongelma, joka ratkaistaan:**
Tarve sitoutua tiettyyn “sopimukseen” useissa luokissa ilman, että käytetään moniperintää. Lisäksi on tarve määritellä yhteisiä metodeja, joita eri luokat voivat toteuttaa omilla tavoillaan.

**Ratkaisu:**
*Rajapinta (interface)*määrittelee joukon metodeja (ja/tai ominaisuuksia), jotka luokan on toteutettava, jos se haluaa “noudattaa” rajapintaa. Tämä antaa joustavuutta, sillä yksi luokka voi toteuttaa useita rajapintoja.

### Rajapinnan avulla (ratkaisu)

```
`![](@@PLUGINFILE@@/image%20%2811%29.png)

![](@@PLUGINFILE@@/image%20%2812%29.png)
`
```
---

## Yhteenveto

 Nämä tekniikat—kapselointi, perintä, polymorfismi, yhdistäminen ja rajapinnat— muodostavat olio-ohjelmoinnin perustan. Jokainen niistä ratkaisee tietyn luonteisen ongelman, mutta yhdessä ne luovat kokonaisuuden, jolla saadaan koodista**selkeämpää, ylläpidettävämpää ja joustavampaa**.

## Inheritance (perintä)
Inheritance in C# is a fundamental concept of object-oriented programming (OOP) that allows a class (called a derived or child class) to inherit attributes and methods from another class (called a base or parent class). This mechanism helps in promoting code reusability and establishing a relationship between classes.

### Key Points for Beginners:
1. **Reusability:**Inheritance allows a new class to use the methods and properties of an existing class without rewriting the code.
1. **Hierarchy:**It helps in creating a hierarchical classification of classes. For instance, you can have a base class`Animal`and derived classes like`Dog`,`Cat`, which are specific types of`Animal`.
1. **`base`Keyword:**Used to access members of the base class from the derived class.
1. **Overriding:**Derived classes can modify or enhance the behavior of base class methods.

### Basic Syntax:

![](@@PLUGINFILE@@/image.png)

### Example 1: Simple Inheritance

![](@@PLUGINFILE@@/image%20%281%29.png)

 In this example,`Car`inherits from`Vehicle`. The`Car`class has all properties and methods of`Vehicle`, plus any additional properties or methods defined in`Car`.

### Example 2: Method Overriding

![](@@PLUGINFILE@@/image%20%282%29.png)

 In this example, the`MakeSound`method in`Dog`overrides the same method in`Animal`. The`virtual`keyword in the base class and`override`keyword in the derived class are used to achieve this.

## Rajapinnat (Interfaces)
### Mitä rajapinnat ovat?

[Rajapinnat](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface) antavat mahdollisuuden määritellä "sopimus", jonka toteuttavat luokat on täytettävä. Toisin kuin perintä, joka kuvaa "on" -suhdetta, rajapinnat usein kuvaavat "voi tehdä" -suhteita, esimerkiksi "Lentokone voi lentää". Rajapinnat antavat luokille mahdollisuuden toteuttaa useita toimintoja ilman monen perinnän monimutkaisuutta.

### Miksi rajapintoja käytetään?
1. **Monimuotoisuus**: Rajapintojen avulla eri luokkia voidaan käsitellä yhtenäisesti, kunhan ne toteuttavat saman rajapinnan.

![](@@PLUGINFILE@@/image.png)
1. **Joustavuus ja laajennettavuus**: Voit vaihtaa rajapintaa toteuttavia komponentteja ilman, että koodissa oleva muu toiminnallisuus kärsii.
![](@@PLUGINFILE@@/image%20%281%29.png)
1. **Moniperintä**: Koska C# ei tue luokkien moniperintää, rajapintoja voidaan käyttää saavuttamaan samankaltainen vaikutus.
![](@@PLUGINFILE@@/image%20%282%29.png)

### Muita huomioita:
- Rajapinnoissa ei voi olla jäsenmuuttujia, mutta niissä voi olla[propertyjä](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties) (ominaisuuksia suomeksi? en ole varma, koska olemme ammattikielessä aina puhuneet "properteistä"/"propertyistä").
![](@@PLUGINFILE@@/image%20%284%29.png)
- Rajapinnoissa ei voi olla määritettyjä konstruktoreita, koska ne eivät sisällä toteutusta tosin kuin luokat.
- Yhdessä luokassa voidaan toteuttaa monta rajapintaa, mutta perintä voi tapahtua vain yhdestä yläluokasta.

#### Mitä yleisiä tekniikoita rajapinnat mahdollistavat (ei kysytä tentissä):

 Rajapinnat ovat keskeisiä ohjelmistosuunnittelun periaatteiden ja suunnittelumallien (design patterns) toteuttamisessa. Ne mahdollistavat useita tekniikoita ja malleja, jotka parantavat ohjelmistojen joustavuutta, laajennettavuutta ja ylläpidettävyyttä. Tässä on muutamia tekniikoita ja suunnittelumalleja, joissa rajapinnat ovat keskeisessä roolissa:
1. **[Dependency Inversion Principle](https://dotnettutorials.net/lesson/dependency-inversion-principle/) (DIP)**: Tämä on yksi[SOLID](https://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/) -periaatteista. Sen sijaan, että korkean tason moduulit olisivat riippuvaisia alhaisen tason moduuleista, molempien tulisi olla riippuvaisia abstraktioista (esim. rajapinnoista).
1. **[Strategy Pattern](https://refactoring.guru/design-patterns/strategy/csharp/example)**: Suunnittelumalli, joka mahdollistaa algoritmin valinnan lennossa. Rajapinnan avulla määritellään toiminto, ja eri strategiat toteutetaan rajapinnan määrittelemiä luokkia hyödyntäen.
1. **[Factory Pattern](https://refactoring.guru/design-patterns/factory-method/csharp/example)**: Käytetään objektien luomiseen. Rajapinta määrittelee tehtaan, joka luo objekteja, ja konkreettiset tehtaat toteuttavat tämän rajapinnan.
1. **[Adapter Pattern](https://refactoring.guru/design-patterns/adapter/csharp/example)**: Muuntaa yhden luokan rajapinnan toisen luokan odottamaksi rajapinnaksi.
1. **[Decorator Pattern](https://refactoring.guru/design-patterns/decorator)**: Lisää dynaamisesti uusia vastuita olemassa olevalle objektille. Tämä saavutetaan "koristamalla" tai "paketoimalla" alkuperäinen objekti rajapinnan määrittelemässä koristeluobjektissa.
1. **Observer Pattern**: Objekti (subjekti) pitää luetteloa riippuvuuksistaan (tarkkailijoista) ja ilmoittaa niille automaattisesti kaikista tilanmuutoksista, yleensä kutsuen jokin niiden metodeista. Esimerkiksi tätä käytetään viestintäsovelluksissa, kuten WhatsApp .
1. **[Dependency Injection](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection)**: Tekniikka, jossa luokan riippuvuudet (esim. palvelut tai muut komponentit) syötetään luokalle sen sijaan, että luokka loisi ne itse. Tämä parantaa modulaarisuutta ja testattavuutta. Rajapinnat ovat keskeisessä asemassa, koska riippuvuudet yleensä määritellään rajapintojen kautta.
1. **[Mock Testing](https://www.telerik.com/blogs/how-to-simplify-your-csharp-unit-testing-mocking-framework)**: Kun testaat sovelluksia, saatat tarvita väliaikaisia toteutuksia tiettyjen toimintojen simuloimiseksi. Rajapintojen avulla voit luoda mock-toteutuksia, jotka auttavat testaamaan sovellusta eristetyssä ympäristössä. Tämä on erittäin tärkeä osa**yksikkötestausta**! Jos joku haluaa tähän tutustua tähän tehtävän muodossa, niin olkaa minuun yhteydessä.

 Rajapinnoilla on monia muitakin käyttötapoja ohjelmoinnissa, ja ne ovat keskeisiä monissa suunnittelumalleissa ja tekniikoissa, joilla pyritään tekemään ohjelmistoista joustavampia, ylläpidettävämpiä ja testattavampia.

## Interfaces
Interfaces in C# are an important concept, especially for beginners learning object-oriented programming (OOP). An interface is like a contract for a class. It defines a set of methods (and properties) that a class must implement but does not provide the implementation itself. Interfaces are useful for establishing a common set of functionalities that different classes can share, but each class can provide its own specific implementation.

### Key Points:
1. **Contract Definition:**An interface defines what methods a class should implement, but it doesn't define how these methods should be implemented.
1. **No Implementation:**Interfaces contain only the declarations of methods, properties, indexers, or events.
1. **Multiple Inheritance:**In C#, a class can inherit from multiple interfaces, enabling some level of multiple inheritance which is not possible with classes.
1. **Polymorphism:**Interfaces support polymorphism. Different classes can implement the same interface and be used interchangeably.
1. **Use`interface`Keyword:**To define an interface, the`interface`keyword is used.

### Basic Syntax:

![](@@PLUGINFILE@@/image.png)

### Example 1: Simple Interface

![](@@PLUGINFILE@@/image%20%281%29.png)

 In this example,`IDriveable`is an interface with two methods. The`Car`class implements this interface by providing specific implementations of the`StartEngine`and`StopEngine`methods.

### Example 2: Multiple Interfaces

![](@@PLUGINFILE@@/image%20%282%29.png)

 Here,`Car`implements two interfaces:`IDriveable`and`IRefuelable`. This demonstrates how a class can implement multiple interfaces and thus adhere to multiple contracts.

 Interfaces are a cornerstone of C#'s OOP capabilities, promoting loose coupling and code reusability, making them highly useful in many programming scenarios.
